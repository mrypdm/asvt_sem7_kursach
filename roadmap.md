# Карта проекта

### 1. Ассемблер

1. Удалить комменты
2. Вычленить самописные макросы
3. Раскрыть макросы
4. Подсчитать кол-во слов памяти для программы
5. Расставить адреса меток
6. Пишем битики:
    1. Код операции
    2. Операнды (регистр+ режим адресации)
    3. Доп. слова (числа, относительные расстояния и т.п.)

### 2. Дизассемблер

> Возможно не нужен, т.к. можно просто сразу трактовать битики

см. [Классы](#классы)

### 3. Executor

1. Прерывание (если есть и если более приоритетное) (см. [Прерывания](#5-прерывания))
2. Извлечь команду
3. Декодировать
4. Исполнить
5. Повторить, пока не HALT либо пошаговый режим - остановиться и ждать следующей команды

> Можно потребовать от юзера явно вводить HALT

### 4. Внешние устройства

1. Подключение через компорт
2. Адреса регистров задаются юзером через настройки
3. Общение через регистры обычными операндами, т.к. регистры мапятся на адресное пространство
4. Протокол общения уже лежит на плечах юзера

### 5. Прерывания

1. У ВУ есть readonly регистр с адресом его вектора прерывания, для удобства можно задавать его через настройки
2. Юзер через код инициализирует прерывания
3. О прерывании должно сообщать ВУ, но как это сделать - хз; Просто в отдельном потоке чекать (или в главном перед
   извлечением команды) все устройства на наличие прерывания?

> Я в целом хз, как общаться через компорт, т.к. это последовательный способ, а не параллельный. Как записывать в
> регистры - хз. Тут думать придется сильно

### 6. GUI

1. Поле ввода текста
2. Кнопки _Создать_, _Открыть_, _Сохранить_, _Сохранить как_, _Закрыть_
3. Кнопка _Настройки_
    1. Управление шрифтом редактора
    2. [Управление ВУ](#61-управление-ву)
4. Кнопка _Справка_
    1. О программе
    2. Список команд
5. Кнопка _Компиляция_
6. Кнопки _Старт_, _Стоп_
7. Кнопка _Шаг_ (пошаговый режим)

#### 6.1. Управление ВУ

Список, в который можно добавлять ком-порты:
1. Кнопки _Добавить_, _Удалить_
2. При добавлении открывается всплывающее окно со всеми ком-портами, юзер выбирает и нажимает _ОК_

При выборе элемента списка открывается окно, в котором:
1. Адрес буферного регистра ввода
2. Адрес буферного регистра вывода
3. Адрес регистра управления ввода
4. Адрес регистра управления вывода
5. Адрес вектора прерывания ввода
6. Адрес вектора прерывания вывода
7. Кнопка _Сохранить_

> (1-6) - поля для ввода; в PDP-11 для адресов ВУ выделены верхние адреса 17****,
> мб проверку добавить или разрешить все адреса - но тогда юзер сам дурак, если что-то сломает

## Классы

```
Memory:
   byte[] Data;
   
   byte GetByte(int address);
   void SetByte(int address, byte value);
```

> Хз, но правильно будет, мб, сделать ее байтовой, а слова вынести на уровень команд и операндов. Хотя удобно будет
> просто вызвать GetWord(addr), вместо двух GetByte(addr) - будем посмотреть

```
Argument:
   Memory Memory;
   int RegisterNumber;
   int AddressationType;
   bool IsByteOperand;
   
   int GetAddress();
   TRes GetValue();
   void SetValue(TVal value);
```

> Мб вместо GetValue/SetValue и типа операнда сделать методы Get/SetByte и Get/SetWord

> Можно еще тогда сделать класс Word - просто обертка над двумя байтами

```
Command:
   Argument[] Arguments;
   
   void Execute();
```

> Мб сделать его абстрактным и сделать много наследников (MovCommand, SumCommand и т.д.), и в конструкторах проверять
> валидность операндов

> Мб вместо классов просто Callable использовать, в целом все команды ведь уже изветсны, их можно статически прописать