# Карта проекта

### 1. Ассемблер
1. Удалить комменты
2. Вычленить самописные макросы
3. Раскрыть макросы
4. Подсчитать кол-во слов памяти для программы
5. Расставить адреса меток
6. Пишем битики:
    1. Код операции
    2. Операнды (регистр+ режим адресации)
    3. Доп. слова (числа, относительные расстояния и т.п.)

### 2. Дизассемблер
> Возможно не нужен, т.к. можно просто сразу трактовать битики

см. [Классы](#классы)

### 3. Executor
1. Прерывание (если есть и если более приоритетное) (см. [Прерывания](#5-прерывания))
2. Извлечь команду
3. Декодировать
4. Исполнить
5. Повторить, пока не HALT
> Можно потребовать от юзера явно вводить HALT

### 4. Внешние устройства
1. Подключение через компорт
2. Адреса регистров задаются юзером через настройки
3. Общение через регистры обычными операндами, т.к. регистры мапятся на адресное пространство
4. Протокол общения уже лежит на плечах юзера

### 5. Прерывания
1. У ВУ есть readonly регистр с адресом его вектора прерывания, для удобства можно задавать его через настройки
2. Юзер через код инициализирует прерывания 
3. О прерывании должно сообщать ВУ, но как это сделать - хз; Просто в отдельном потоке чекать (или в главном перед извлечением команды) все устройства на наличие прерывания?

> Я в целом хз, как общаться через компорт, т.к. это последовательный способ, а не параллельный. Как записывать в регистры - хз. Тут думать придется сильно

## Классы

```
Memory:
   byte[] Data;
   
   byte GetByte(int address);
   void SetByte(int address, byte value);
```
> Хз, но правильно будет, мб, сделать ее байтовой, а слова вынести на уровень команд и операндов. Хотя удобно будет просто вызвать GetWord(addr), вместо двух GetByte(addr) - будем посмотреть

```
Argument:
   Memory Memory;
   int RegisterNumber;
   int AddressationType;
   bool IsByteOperand;
   
   int GetAddress();
   TRes GetValue();
   void SetValue(TVal value);
```
> Мб вместо GetValue/SetValue и типа операнда сделать методы Get/SetByte и Get/SetWord

> Можно еще тогда сделать класс Word - просто обертка над двумя байтами
```
Command:
   Argument[] Arguments;
   
   void Execute();
```
> Мб сделать его абстрактным и сделать много наследников (MovCommand, SumCommand и т.д.), и в конструкторах проверять валидность операндов

> Мб вместо классов просто Callable использовать, в целом все команды ведь уже изветсны, их можно статически прописать